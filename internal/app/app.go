package app

import (
	"encoding/json"
	"flag"
	"fmt"
	"github.com/worldiety/xtractdoc/internal/api"
	"github.com/worldiety/xtractdoc/internal/golang"
	"gopkg.in/yaml.v3"
	"strings"
)

const (
	Yaml = "yaml"
	Json = "json"
)

type Config struct {
	ModPath      string
	OutputFormat string
	Packages     string
	PkgSep       string
}

func (c *Config) Reset() {
	wd, err := golang.ModWdRoot()
	if err != nil {
		fmt.Println(err)
	}

	c.ModPath = wd
	c.OutputFormat = Yaml
	c.PkgSep = "/"
}

func (c *Config) Flags(flags *flag.FlagSet) {
	flags.StringVar(&c.ModPath, "modPath", c.ModPath, "the modules path to use")
	flags.StringVar(&c.OutputFormat, "format", c.OutputFormat, "either yaml|json")
	flags.StringVar(&c.Packages, "packages", c.Packages, "if not empty, only scan the listed packages separated by ;")
	flags.StringVar(&c.PkgSep, "pkgSep", c.PkgSep, "sets the path separator between packages. Default is / which is not json-pointer friendly")
}

func Apply(cfg Config) ([]byte, error) {
	pkgs := strings.Split(cfg.Packages, ";")
	if len(pkgs) == 1 && pkgs[0] == "" {
		pkgs = nil
	}

	node, err := golang.Parse(cfg.ModPath, pkgs...)
	if err != nil {
		return nil, fmt.Errorf("cannot parse from %s: %w", cfg.ModPath, err)
	}

	tmp := map[api.ImportPath]*api.Package{}
	if cfg.PkgSep != "/" {
		for path, p := range node.Packages {
			qualifier := strings.ReplaceAll(path, "/", cfg.PkgSep)
			tmp[qualifier] = p

			var impTmp []string
			for _, s := range p.Imports {
				qualifier := strings.ReplaceAll(s, "/", cfg.PkgSep)
				impTmp = append(impTmp, qualifier)
			}
			p.Imports = impTmp
		}

		node.Packages = tmp
	}

	switch cfg.OutputFormat {
	case Json:
		buf, err := json.Marshal(node)
		if err != nil {
			return nil, fmt.Errorf("cannot marshal json: %w", err)
		}

		return buf, nil

	case Yaml:
		buf, err := yaml.Marshal(node)
		if err != nil {
			return nil, fmt.Errorf("cannot marshal yaml: %w", err)
		}

		buf = append([]byte("# Code generated by github.com/worldiety/xtractdoc DO NOT EDIT.\n\n"), buf...)

		return buf, nil
	default:
		return nil, fmt.Errorf("invalid output format: %s", cfg.OutputFormat)
	}
}
