package app

import (
	"encoding/json"
	"flag"
	"fmt"
	"github.com/worldiety/xtractdoc/internal/golang"
	"gopkg.in/yaml.v3"
	"strings"
)

const (
	Yaml = "yaml"
	Json = "json"
)

type Config struct {
	ModPath      string
	OutputFormat string
	Packages     string
	PkgSep       string
}

func (c *Config) Reset() {
	wd, err := golang.ModWdRoot()
	if err != nil {
		fmt.Println(err)
	}

	c.ModPath = wd
	c.OutputFormat = Yaml
	c.PkgSep = "/"
}

func (c *Config) Flags(flags *flag.FlagSet) {
	flags.StringVar(&c.ModPath, "modPath", c.ModPath, "the modules path to use")
	flags.StringVar(&c.OutputFormat, "format", c.OutputFormat, "either yaml|json")
	flags.StringVar(&c.Packages, "packages", c.Packages, "if not empty, only scan the listed packages separated by ;")
	flags.StringVar(&c.PkgSep, "pkgSep", c.PkgSep, "sets the path separator between packages. Default is / which is not json-pointer friendly")
}

func Apply(cfg Config) ([]byte, error) {

	comments := map[string]string{}
	pkgs := strings.Split(cfg.Packages, ";")
	if len(pkgs) == 1 && pkgs[0] == "" {
		pkgs = nil
	}

	docs, err := golang.Parse(cfg.ModPath, pkgs...)
	if err != nil {
		return nil, fmt.Errorf("cannot parse from %s: %w", cfg.ModPath, err)
	}

	for _, doc := range docs {
		qualifier := strings.ReplaceAll(doc.Qualifier, "/", cfg.PkgSep)
		comments[qualifier] = doc.Doc
	}

	switch cfg.OutputFormat {
	case Json:
		buf, err := json.Marshal(comments)
		if err != nil {
			return nil, fmt.Errorf("cannot marshal json: %w", err)
		}

		return buf, nil

	case Yaml:
		buf, err := yaml.Marshal(comments)
		if err != nil {
			return nil, fmt.Errorf("cannot marshal yaml: %w", err)
		}

		buf = append([]byte("# Code generated by github.com/worldiety/xtractdoc DO NOT EDIT.\n\n"), buf...)

		return buf, nil
	default:
		return nil, fmt.Errorf("invalid output format: %s", cfg.OutputFormat)
	}

}
